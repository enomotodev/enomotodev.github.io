<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mysql on enomotodev</title>
    <link>http://enomotodev.github.io/tags/mysql/</link>
    <description>Recent content in Mysql on enomotodev</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja_JP</language>
    <managingEditor>enomoto.dev@gmail.com (Takafumi Enomoto)</managingEditor>
    <webMaster>enomoto.dev@gmail.com (Takafumi Enomoto)</webMaster>
    <copyright>(c) 2015 Takafumi Enomoto.</copyright>
    <lastBuildDate>Thu, 19 Nov 2015 23:53:29 +0900</lastBuildDate>
    <atom:link href="http://enomotodev.github.io/tags/mysql/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>閉包テーブル（Closure Table）を試してみた</title>
      <link>http://enomotodev.github.io/post/closure-table/</link>
      <pubDate>Thu, 19 Nov 2015 23:53:29 +0900</pubDate>
      <author>enomoto.dev@gmail.com (Takafumi Enomoto)</author>
      <guid>http://enomotodev.github.io/post/closure-table/</guid>
      <description>

&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;SQLアンチパターンという本を読んでいたら、再帰的なデータに対して『閉包テーブル（Closure Table）』という考え方があっったので、MySQL 5.6 で試してみました。&lt;br /&gt;
再帰的なデータとは、例えば上司を1人までもつことができ、部下は複数持つことができる、下記の組織図のようなツリー構造のデータのことを指します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://enomotodev.github.io/images/soshikizu.png&#34; alt=&#34;組織図&#34; class=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;テーブル作成&#34;&gt;テーブル作成&lt;/h2&gt;

&lt;p&gt;それでは早速テーブルを作成してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE TABLE `Employees` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

CREATE TABLE `TreePaths` (
  `ancestor` bigint(20) NOT NULL,
  `descendant` bigint(20) NOT NULL,
  PRIMARY KEY (`ancestor`,`descendant`),
  KEY `descendant` (`descendant`),
  CONSTRAINT `TreePaths_ibfk_1` FOREIGN KEY (`ancestor`) REFERENCES `Employees` (`id`),
  CONSTRAINT `TreePaths_ibfk_2` FOREIGN KEY (`descendant`) REFERENCES `Employees` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;閉包テーブルでは、Employees テーブルに自分自身の id を親に持つカラムを設けるのではなく、別のテーブルを用いて、ツリー構造の情報を格納します。&lt;br /&gt;
このテーブルには親子関係の組み合わせを格納するのですが、直接の子ではない（2つ以上離れている）場合も子と見なすのと、自分自身も子と見なします。&lt;br /&gt;
下の図の場合、１の子は１〜８の全てになり、３の子は３〜４、５の子は５〜８といった感じになります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://enomotodev.github.io/images/soshikizu_num.png&#34; alt=&#34;組織図（番号）&#34; class=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;一応、テーブルにまとめました。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;親&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;子&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;親&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;子&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;親&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;子&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;親&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;子&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;親&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;子&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;6&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;7&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;7&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;データ作成&#34;&gt;データ作成&lt;/h2&gt;

&lt;p&gt;このあと実際にクエリを発行したりするので、テストデータを INSERT しておきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;INSERT INTO `Employees` (`id`, `name`) VALUES
(1, &amp;quot;遠藤&amp;quot;), (2, &amp;quot;田中&amp;quot;), (3, &amp;quot;佐藤&amp;quot;), (4, &amp;quot;原田&amp;quot;),
(5, &amp;quot;吉田&amp;quot;), (6, &amp;quot;古田&amp;quot;), (7, &amp;quot;鈴木&amp;quot;), (8, &amp;quot;松井&amp;quot;);

INSERT INTO `TreePaths` (`ancestor`, `descendant`) VALUES
(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (1, 8),
(2, 2), (3, 3), (3, 4), (4, 4), (5, 5), (5, 6), (5, 7), (5, 8),
(6, 6), (6, 7), (7, 7), (8, 8);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;子を全取得&#34;&gt;子を全取得&lt;/h2&gt;

&lt;p&gt;子を全取得するのはとても簡単にできます。&lt;br /&gt;
例えば５の子を全部取得するには TreePaths テーブルで親が５の行を探すだけです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SELECT e.*
    -&amp;gt; FROM Employees AS e
    -&amp;gt;   INNER JOIN TreePaths AS t ON e.id = t.descendant
    -&amp;gt; WHERE t.ancestor = 5;
+----+--------+
| id | name   |
+----+--------+
|  5 | 吉田   |
|  6 | 古田   |
|  7 | 鈴木   |
|  8 | 松井   |
+----+--------+
4 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;親を全取得&#34;&gt;親を全取得&lt;/h2&gt;

&lt;p&gt;次に、７の親を全部取得してみます。
先ほどとは逆に TreePaths テーブルで子が７の行を探すだけです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SELECT e.*
    -&amp;gt; FROM Employees AS e
    -&amp;gt;   INNER JOIN TreePaths AS t ON e.id = t.ancestor
    -&amp;gt; WHERE t.descendant = 7;
+----+--------+
| id | name   |
+----+--------+
|  1 | 遠藤   |
|  5 | 吉田   |
|  6 | 古田   |
|  7 | 鈴木   |
+----+--------+
4 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;データを登録&#34;&gt;データを登録&lt;/h2&gt;

&lt;p&gt;IDが４のデータに子をひとつ登録してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;INSERT INTO Employees (`name`) VALUES (&amp;quot;本田&amp;quot;);  // LAST_INSERT_ID() = 9

INSERT INTO TreePaths (ancestor, descendant)
  SELECT t.ancestor, 9
  FROM TreePaths AS t
  WHERE t.descendant = 4
UNION ALL
  SELECT 9, 9;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;少しわかりづらいかもしれませんが、考え方としてはIDが４の親全てに新規で追加した子のIDを持たせるといった感じです。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;親一覧の取得、子一覧の取得、データの登録を実際にやってみましたが、どれも比較的簡単なSQLで対応できました。&lt;br /&gt;
他のメリットとしては、どれだけ階層が深くなっても特に問題がないということです。SQLもどれだけ階層が深くなっても変わりません。&lt;/p&gt;

&lt;p&gt;階層構造のデータを格納するときは、この閉包テーブル（Closure Table）を試してみてはいかがでしょうか。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Gooseつかってみた</title>
      <link>http://enomotodev.github.io/post/use-goose/</link>
      <pubDate>Wed, 11 Nov 2015 19:17:08 +0900</pubDate>
      <author>enomoto.dev@gmail.com (Takafumi Enomoto)</author>
      <guid>http://enomotodev.github.io/post/use-goose/</guid>
      <description>

&lt;h2 id=&#34;gooseとは:8514db67a0f0851bcd6441e94b5eb4e6&#34;&gt;Gooseとは&lt;/h2&gt;

&lt;p&gt;GooseとはGo言語で作られたDBマイグレーションツールです。&lt;br /&gt;
develop環境やproduction環境など各環境に簡単に設定を変更でき、かなり便利そうなので実際にMySQLで試してみました。&lt;/p&gt;

&lt;h2 id=&#34;gooseパッケージの取得:8514db67a0f0851bcd6441e94b5eb4e6&#34;&gt;Gooseパッケージの取得&lt;/h2&gt;

&lt;p&gt;まずは go get して Goose パッケージを取得します。&lt;br /&gt;
※ Goをインストールしていない人や、GOPATHを設定していない人は&lt;a href=&#34;http://golang-jp.org/doc/install#install&#34; target=&#34;_blank&#34;&gt;公式ドキュメント&lt;/a&gt;を参考に導入してみてください。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get bitbucket.org/liamstask/goose/cmd/goose
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;dbディレクトリの作成:8514db67a0f0851bcd6441e94b5eb4e6&#34;&gt;dbディレクトリの作成&lt;/h2&gt;

&lt;p&gt;プロジェクトのルート直下に db ディレクトリを作成します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir db
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;configファイルの作成:8514db67a0f0851bcd6441e94b5eb4e6&#34;&gt;configファイルの作成&lt;/h2&gt;

&lt;p&gt;取得したGooseパッケージのサンプルからconfigファイルをコピーします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cp $GOPATH/src/bitbucket.org/liamstask/goose/db-sample/dbconf.yml db/
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;configファイルの編集:8514db67a0f0851bcd6441e94b5eb4e6&#34;&gt;configファイルの編集&lt;/h2&gt;

&lt;p&gt;まずは先ほどコピーしてきたconfigファイルの中身をのぞいてみます。&lt;br /&gt;
デフォルトで test / develop / production のそれぞれの環境に PostgreSQL の driver が設定してあるのが、なんとなくわかるかと思います。&lt;/p&gt;

&lt;p&gt;db/dbconf.yml&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;test:
    driver: postgres
    open: user=liam dbname=tester sslmode=disable

development:
    driver: postgres
    open: user=liam dbname=tester sslmode=disable

production:
    driver: postgres
    open: user=liam dbname=tester sslmode=verify-full

customimport:
    driver: customdriver
    open: customdriver open
    import: github.com/custom/driver
    dialect: mysql

environment_variable_config:
    driver: $DB_DRIVER
    open: $DATABASE_URL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今回は試すだけなので、developの部分のみ編集してみます。&lt;br /&gt;
MySQL のdriverは mymysql とのことなので、 driver には mymysql を設定します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;development:
    driver: mymysql
    open: user=liam dbname=tester sslmode=disable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に DB に接続するために open の箇所にユーザ名やデータベース名を設定します。&lt;br /&gt;
何種類か設定の仕方があるようなので下記を参考にしてみてください。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DBNAME/USER/PASSWD&lt;/li&gt;
&lt;li&gt;unix:SOCKPATH*DBNAME/USER/PASSWD&lt;/li&gt;
&lt;li&gt;unix:SOCKPATH,OPTIONS*DBNAME/USER/PASSWD&lt;/li&gt;
&lt;li&gt;tcp:ADDR*DBNAME/USER/PASSWD&lt;/li&gt;
&lt;li&gt;tcp:ADDR,OPTIONS*DBNAME/USER/PASSWD&lt;/li&gt;
&lt;li&gt;cloudsql:INSTANCE*DBNAME/USER/PASSWD&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考までに下記のような場合の設定を載せておきます。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Host：localhost&lt;br /&gt;
Port：3306&lt;br /&gt;
データベース：test&lt;br /&gt;
ユーザ：root&lt;br /&gt;
パスワード：pass&lt;/p&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;development:
    driver: mymysql
    open: tcp:localhost:3306*test/root/pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでDBの設定は完了です。&lt;/p&gt;

&lt;h2 id=&#34;db接続確認:8514db67a0f0851bcd6441e94b5eb4e6&#34;&gt;DB接続確認&lt;/h2&gt;

&lt;p&gt;goose status コマンドでDBに問題なく接続できているか確認できます。&lt;br /&gt;
これ以降の goose コマンドも全てプロジェクトルートで実行してください。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ goose status
goose: status for environment &#39;development&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記のようにエラーなく表示されたらOKです。&lt;/p&gt;

&lt;h2 id=&#34;マイグレーションファイルの作成:8514db67a0f0851bcd6441e94b5eb4e6&#34;&gt;マイグレーションファイルの作成&lt;/h2&gt;

&lt;p&gt;それではDB接続もOKなので、早速マイグレーションファイルを作りましょう。&lt;/p&gt;

&lt;p&gt;マイグレーションファイルは Go または SQL で書けるようなので、今回は簡単なSQLで書いてみます。&lt;/p&gt;

&lt;p&gt;それでは、goose create コマンドでマイグレーションファイルを作成します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ goose create CreateUsersTable sql
goose: created /project/db/migrations/20151111194459_CreateUsersTable.sql.sql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだけでマイグレーションファイルのひな型が作成されました。&lt;br /&gt;
早速中身を見てみましょう。&lt;/p&gt;

&lt;p&gt;db/migrations/20151111194459_CreateUsersTable.sql&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-- +goose Up
-- SQL in section &#39;Up&#39; is executed when this migration is applied


-- +goose Down
-- SQL section &#39;Down&#39; is executed when this migration is rolled back
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このファイルにCREATE文とDROP文をそれぞれ書きます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-- +goose Up
-- SQL in section &#39;Up&#39; is executed when this migration is applied
CREATE TABLE IF NOT EXISTS `users` (
    `id` INT NOT NULL AUTO_INCREMENT,
    `name` VARCHAR(255) NOT NULL COMMENT &#39;ユーザ名&#39;,
    PRIMARY KEY (`id`)
) ENGINE = InnoDB;

-- +goose Down
-- SQL section &#39;Down&#39; is executed when this migration is rolled back
DROP TABLE `users`;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでマイグレーションファイルの準備はできたので、実際に実行してテーブルが作成されるか確認してみましょう。&lt;/p&gt;

&lt;h2 id=&#34;マイグレーションの実行:8514db67a0f0851bcd6441e94b5eb4e6&#34;&gt;マイグレーションの実行&lt;/h2&gt;

&lt;p&gt;goose up コマンドでマイグレーションが実行されます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ goose up
goose: migrating db environment &#39;development&#39;, current version: 0, target: 20151111194459
OK    20151111194459_CreateUsersTable.sql.sql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;テーブルが作成されているか確認してみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show tables;
+------------------+
| Tables_in_test   |
+------------------+
| goose_db_version |
| users            |
+------------------+
1 row in set (0.00 sec)

mysql&amp;gt; desc goose_db_version;
+------------+---------------------+------+-----+-------------------+----------------+
| Field      | Type                | Null | Key | Default           | Extra          |
+------------+---------------------+------+-----+-------------------+----------------+
| id         | bigint(20) unsigned | NO   | PRI | NULL              | auto_increment |
| version_id | bigint(20)          | NO   |     | NULL              |                |
| is_applied | tinyint(1)          | NO   |     | NULL              |                |
| tstamp     | timestamp           | YES  |     | CURRENT_TIMESTAMP |                |
+------------+---------------------+------+-----+-------------------+----------------+
4 rows in set (0.00 sec)

mysql&amp;gt; select * from goose_db_version;
+----+----------------+------------+---------------------+
| id | version_id     | is_applied | tstamp              |
+----+----------------+------------+---------------------+
|  1 |              0 |          1 | 2015-11-11 19:49:59 |
|  2 | 20151111194459 |          1 | 2015-11-11 19:49:59 |
+----+----------------+------------+---------------------+
2 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;usersテーブルが作成されているのと、マイグレーションのバージョン管理用の goose_db_version テーブルが作成されているのが確認できました。&lt;br /&gt;
次に今実行したマイグレーションをロールバックしてみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ goose down
goose: migrating db environment &#39;development&#39;, current version: 20151111194459, target: 0
OK    20151111194459_CreateUsersTable.sql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;確認してみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show tables;
+------------------+
| Tables_in_test   |
+------------------+
| goose_db_version |
+------------------+
1 row in set (0.00 sec)

mysql&amp;gt; select * from goose_db_version;
+----+----------------+------------+---------------------+
| id | version_id     | is_applied | tstamp              |
+----+----------------+------------+---------------------+
|  1 |              0 |          1 | 2015-11-11 19:49:59 |
|  2 | 20151111194459 |          1 | 2015-11-11 19:49:59 |
|  3 | 20151111194459 |          0 | 2015-11-11 19:53:28 |
+----+----------------+------------+---------------------+
3 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;usersテーブルが削除されているのが確認できました。&lt;/p&gt;

&lt;h2 id=&#34;まとめ:8514db67a0f0851bcd6441e94b5eb4e6&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;goose をつかうことによって、簡単にマイグレーションすることができました。&lt;br /&gt;
最近、Go言語を使ったプロジェクトも増えてきているようなので、goose もこれからさらに活躍する場面が増えるのではないでしょうか。&lt;/p&gt;

&lt;hr /&gt;
</description>
    </item>
    
  </channel>
</rss>